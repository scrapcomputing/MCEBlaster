#!/bin/bash
set -e

PORCH_ITER=2   # If the horiz porch is too short this may need to be decreased

cmake_txt=CGAPio.cmake
echo "# Automatically generated by $(basename ${0}) DO NOT EDIT!" > ${cmake_txt}

pio_h=CGAPio.h
echo "// Automatically generated by $(basename ${0}) DO NOT EDIT!" > ${pio_h}
echo "#pragma once" >> ${pio_h}

MaxSamplingOffset=8
echo "static constexpr const uint32_t CGAMaxSamplingOffset = ${MaxSamplingOffset};" >> ${pio_h}

for HSync in PosHSync NegHSync; do
    switch_case_program_cpp=CGASwitchCase_${HSync}_program_cpp
    echo "// Automatically generated by $(basename ${0}) DO NOT EDIT!" > ${switch_case_program_cpp}

    switch_case_config_cpp=CGASwitchCase_${HSync}_config_cpp
    echo "// Automatically generated by $(basename ${0}) DO NOT EDIT!" > ${switch_case_config_cpp}

    for i in {4..16}; do
        for sampling_offset in $(seq 0 ${MaxSamplingOffset}); do
            idx=$(printf "%02d" ${i})
            file="CGA640x200_${HSync}_delay${idx}_offset${sampling_offset}.pio"
            delay1=$((${i} - 1))
            offset=$((${i}/2))
            echo 'pico_generate_pio_header(${PROJECT_NAME} ${CMAKE_CURRENT_LIST_DIR}/Pio/CGA640x200_'"${HSync}"'_'"delay${idx}"'_'"offset${sampling_offset}"'.pio)' >> ${cmake_txt}
            echo "#include \"CGA640x200_${HSync}_delay${idx}_offset${sampling_offset}.pio.h\"" >> ${pio_h}
            echo "if (InstrDelay == ${i} && SamplingOffset == ${sampling_offset}) return &CGA640x200_${HSync}_delay${idx}_offset${sampling_offset}_program;" >> ${switch_case_program_cpp}
            echo "if (InstrDelay == ${i} && SamplingOffset == ${sampling_offset}) return CGA640x200_${HSync}_delay${idx}_offset${sampling_offset}_program_get_default_config(Offset);" >> ${switch_case_config_cpp}
            if [ "${HSync}" == "PosHSync" ]; then
                delay2=$((${delay1} - 3))
                cat > ./Pio/${file} <<EOF
;; Copyright (C) 2025 Scrap Computing
;; Automatically generated by $(basename ${0}) DO NOT EDIT!
.program CGA640x200_${HSync}_delay${idx}_offset${sampling_offset}
.define TTL_PIN_CNT 8
.define HSYNC_GPIO 7

; Pixel clock 640 mode: 14.318MHz (315/22):  69.84ns/pixel 18.857 instrs (3.704ns/instr)
; Pixel clock 320 mode:  7.159MHz (315/44): 140ns/pixel

entry:

.wrap_target
   set y ${PORCH_ITER}     ; Porch iteration counter (see jmp y-- below)
loop:
   in pins, TTL_PIN_CNT [${delay1}]
   in pins, TTL_PIN_CNT [${delay1}]
   in pins, TTL_PIN_CNT [${delay1}]
   in pins, TTL_PIN_CNT [${delay2}]   ; ISR = RRGGBBHV(#3),RRGGBBHV(#2),RRGGBBHV(#1),RRGGBBHV(#0)
   push noblock               ; FIFO = ISR (#3,#2,#1,#0)
   jmp pin wait_hsync
   jmp loop

wait_hsync:
   jmp y-- loop ; A few more iterations until the TTLReader receives all pixels
                ; in the fifo queue, otherwise 'push noblock' below will override
                ; them with black pixels, resulting in horizontal clipping
   set y 0      ; Make sure we don't take the jmp y-- loop

   in null, 32
   push noblock
   jmp pin wait_hsync
   wait 0 gpio HSYNC_GPIO [${sampling_offset}] ; sampling offset
   .wrap                      ; jmp loop
EOF
            else
                delay2=$((${delay1} - 2))
                cat > ./Pio/${file} <<EOF
;; Copyright (C) 2025 Scrap Computing
;; Automatically generated by $(basename ${0}) DO NOT EDIT!
.program CGA640x200_${HSync}_delay${idx}_offset${sampling_offset}
.define TTL_PIN_CNT 8
.define HSYNC_GPIO 7

; Pixel clock 640 mode: 14.318MHz (315/22):  69.84ns/pixel 18.857 instrs (3.704ns/instr)
; Pixel clock 320 mode:  7.159MHz (315/44): 140ns/pixel

entry:

.wrap_target
   set y ${PORCH_ITER}     ; Porch iteration counter (see jmp y-- below)
loop:
   in pins, TTL_PIN_CNT [${delay1}]
   in pins, TTL_PIN_CNT [${delay1}]
   in pins, TTL_PIN_CNT [${delay1}]
   in pins, TTL_PIN_CNT [${delay2}]   ; ISR = RRGGBBHV(#3),RRGGBBHV(#2),RRGGBBHV(#1),RRGGBBHV(#0)
   push noblock               ; FIFO = ISR (#3,#2,#1,#0)
   jmp pin loop               ; loop while HSync is 1

   ; HSync is now 0, wait until it becomes 1
wait_hsync_1:
   jmp y-- loop ; A few more iterations until the TTLReader receives all pixels
                ; in the fifo queue, otherwise 'push noblock' below will override
                ; them with black pixels, resulting in horizontal clipping
   set y 0      ; Make sure we don't take the jmp y-- loop

   in null, 32
   push noblock
   jmp pin hsync_is_1         ; break out of loop if HSync is 1
   jmp wait_hsync_1

hsync_is_1:
   wait 1 gpio HSYNC_GPIO [${sampling_offset}] ; sampling offset
   .wrap                      ; jmp loop
EOF
            fi
        done                    # sampling offset
    done                        # delay
done                            # NegHSync PosHSync
